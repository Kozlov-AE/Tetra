<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'MS Shell Dlg 2'; font-size:12pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Вопрос:<br /><span style=" font-size:11pt; color:#15006a;">using (SomeClass sc = new SomeClass()){}</span><br />Что делает данная конструкция?</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />Ответ:<br />Выражение using (в данном случае корректно говорить о нем как о<br />выражении) позволяет использовать в своем блоке кода некоторый ресурс (в<br />данном случае это класс) с последующим неявным вызовом метода Dispose<br />интерфейса IDisposable.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />Для класса<br /><span style=" font-size:11pt; color:#15006a;">class A: IDisposable<br />{<br />public void Dispose()<br />{ }<br />}</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />Данное выражение преобразуется компилятором в следующую конструкцию:<br /><span style=" font-size:11pt; color:#15006a;">A a = new A();<br />try<br />{ }<br />finally<br />{<br />if (a != null)<br />{<br />((IDisposable)a).Dispose();<br />}<br />}</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />Так как класс, это ссылочный тип данных – в блоке finally компилятор добавит<br />проверку на null. Это справедливо также и для nullable значимых типов.<br />Только тогда компилятор добавит проверку на наличия значения:<br /><span style=" font-size:11pt; color:#15006a;">Nullable&lt;A&gt; a = default(A);<br />Try { }<br />finally<br />{<br />if (a.HasValue)<br />{<br />((IDisposable)a.GetValueOrDefault()).Dispose();<br />}<br />}</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br />Если же наш тип является значимым типом, не поддерживающим null, то<br />никаких проверок не будет:<br /><span style=" font-size:11pt; color:#15006a;">A a = default(A);<br />try<br />{ }<br />finally<br />{<br />((IDisposable)a).Dispose();<br />}</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /><span style=" color:#ff0000;">Коварный вопрос:<br /></span><span style=" color:#000000;">Если наш значимый тип приводится к интерфейсу IDisposable, то ведь он<br />должен быть упакован и его копия должна быть перемещена в кучу. А так как<br />мы вызываем Dispose у копии, то, соответственно, у оригинала Dispose вызван<br />не будет.<br /></span><span style=" color:#00b050;">Ответ:<br /></span><span style=" color:#000000;">Не во всех случаях приведение к типу интерфейса приводит к упаковке<br />значения – компилятор может использовать constrained оптимизацию.<br />Подробнее опкод constrained описан тут:<br /></span><span style=" color:#0563c1;">https://docs.microsoft.com/enus/dotnet/api/system.reflection.emit.opcodes.constrained?view=netcore-3.1</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /><span style=" color:#ff0000;">Коварный вопрос:<br /></span><span style=" color:#000000;">Чем отличается<br /></span><span style=" font-size:11pt; color:#15006a;">A a = new A();<br />using(a)<br />{ }</span><span style=" color:#000000;"><br />От<br /></span><span style=" font-size:11pt; color:#15006a;">using(A a = new A())<br />{ }</span><span style=" color:#000000;"><br />Это одно и тоже?<br /></span><span style=" color:#00b050;">Ответ:<br /></span><span style=" color:#000000;">Нет, это не одно и тоже. Во втором случае все будет так, как описано выше, в<br />первом же случае внутри самого выражения using вы будете работать с<br />переменной </span>a<span style=" color:#000000;">, но Dispose будет вызван у </span><span style=" color:#ff0000;">копии </span><span style=" color:#000000;">данной переменной. Из этого<br />следует что первая запись некорректна.</span> </p></body></html>