<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'MS Shell Dlg 2'; font-size:12pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">Как известно, в Си-шарп все классы являются наследниками базового класса object. В нем есть три виртуальных метода – ToString, Equals и GetHashCode. В этом уроке мы поговорим с вами о последних двух методах, а также об операторе «==». Скажу сразу, что вопрос разницы между оператором равенства «==» и методом Equals является классическим вопросом на собеседовании на вакансию программиста Си-шарп. Оператор равенства «==» По умолчанию при работе с ссылочными типами данных (все классы кроме string, интерфейсы, делегаты) оператор «==» проверяет равенство ссылок. Он возвращает true, когда обе ссылки указывают на один объект, в противном случае – false. Приведу код, который демонстрирует работу данного оператора с ссылочными типами: </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:10pt; color:#6a1009; background-color:#eaf9ff;">static void Main(string[] args)<br />{<br />   object o1 = new object();<br />   object o2 = new object();<br />   object o3 = o1;<br />   Console.WriteLine(o1 == o2); // false<br />   Console.WriteLine(o1 == o3); // true<br />}</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">Здесь создается два объекта, ссылки на которые записываются в переменные o1 и o2. Дальше ссылка o1 копируется в переменную o3 (o1 и o3 указывают на один объект). В итоге имеем false при сравнении ссылок o1 и o2, и true при o1 и o3. Метод Equals Метод Equals принимает один аргумент – объект, который будет сравниваться с текущим объектом, и определяет, равны ли между собой эти объекты. Здесь уже идет речь о равенстве полей объектов, а не ссылок. Этот метод виртуальный, и его базовая реализация это просто проверка равенства ссылок оператором «==». Но когда мы создаем некий класс, и нам необходимо реализовать возможность проверки идентичности объектов, следует переопределить именно данный метод, а не воспользоваться перегрузкой оператора «==», чтобы не спутывать базовые назначения этих инструментов сравнивания. Перегрузка метода Equals При переопределении метода Equals следует позаботиться о том, чтобы этот метод возвращал false в случаях, когда в метод передано значение NULL, когда переданный объект нельзя привести к типу текущего объекта, ну и когда поля объектов отличаются. Возьмем уже знакомый нам класс Money с предыдущего урока, и переопределим в нем метод Equals: </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:10pt; color:#6a1009; background-color:#eaf9ff;">public class Money<br />{<br />   public decimal Amount { get; set; }<br />   public string Unit { get; set; }<br /><br />   public Money(decimal amount, string unit)<br />   {<br />     Amount = amount;<br />     Unit = unit;<br />   }<br /><br />  public override bool Equals(object obj)<br />   {<br />     if (obj == null)<br />       return false;<br />     Money m = obj as Money; // возвращает null если объект нельзя привести к типу Money<br />     if (m as Money == null)<br />       return false;<br /><br />     return m.Amount == this.Amount &amp;&amp; m.Unit == this.Unit;<br />   }<br />}<br />class Program<br />{<br />   static void Main(string[] args)<br />   {<br />     Money m1 = new Money(100, &quot;RUR&quot;);<br />     Money m2 = new Money(100, &quot;RUR&quot;);<br />     Money m3 = new Money(100, &quot;USD&quot;);<br />     Money m4 = m1;<br />     Console.WriteLine(m1.Equals(m2)); // true<br />     Console.WriteLine(m1.Equals(m3)); // false<br />     Console.WriteLine(m1 == m2); // false<br />     Console.WriteLine(m1 == m4); // true<br />     Console.ReadLine();<br />   }<br />}</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">Как видим, в коде выше метод Equals и оператор «==» работают соответственно своим базовым определениям. Также для повышения производительности при переопределении метода Equals рекомендуется перегружать его реализацией с типом аргумента соответствующему классу, в котором он переопределяется: </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:10pt; color:#6a1009;">public bool Equals(Money obj) // аргумент типа Money<br />{<br />   if (obj == null)<br />     return false;<br /><br />   return obj.Amount == this.Amount &amp;&amp; obj.Unit == this.Unit;<br />} </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:13px; color:#000000; background-color:#eeeff0;">Метод GetHashCode Данный метод, как следует из его названия, возвращает хеш-код. Хеш-код это число соответствующее значению объекта. Это число мы получаем в результате работы некоторого метода, который должен обладать следующими свойствами: - он должен возвращать одинаковый хеш-код каждый раз при вызове для одного и того же объекта. - если имеется два равных (эквивалентных) объекта, то хеш-код для них должен быть одинаковым. Только это не означает, что если объекты неравны, то их хеш-коды обязательно будут разными. Метод GetHashCode используется в таких структурах, как хэш-таблицы (Hashtable). Это мы сейчас рассматривать не будем, но корректность их работы стоит обеспечивать. Методы Equals и GetHashCode тесно связанны между собой, при переопределении одного из них, следует переопределять и другой. Базовая реализация метода GetHashCode в классе object очень условная, и она не обеспечивает второе свойство, когда одинаковые объекты имеют одинаковые хеш-коды. </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:10pt; color:#6a1009; background-color:#eaf9ff;">static void Main(string[] args)<br />{<br />   Money m1 = new Money(100, &quot;RUR&quot;);<br />   Money m2 = new Money(100, &quot;RUR&quot;);<br />   Console.WriteLine(m1.GetHashCode()); // 456...<br />   Console.WriteLine(m2.GetHashCode()); // 411...<br />   Console.ReadLine();<br />}</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">Чтобы это исправить, мы переопределяем метод GetHashCode, и возвращаем хеш-код каким-либо способом, зависящим от поля/полей объекта: </span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:20px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:10pt; color:#6a1009; background-color:#eaf9ff;">public class Money<br />{<br />   public decimal Amount { get; set; }<br />   public string Unit { get; set; }<br /><br />   public Money(decimal amount, string unit)<br />   {<br />     Amount = amount;<br />     Unit = unit;<br />   }<br /><br />   public override bool Equals(object obj)<br />   {<br />     if (obj == null)<br />       return false;<br />     Money m = obj as Money;<br />     if (m as Money == null)<br />       return false;<br />     return m.Amount == this.Amount &amp;&amp; m.Unit == this.Unit;<br />   }<br />public bool Equals(Money obj) // аргумент типа Money<br />   {<br />     if (obj == null)<br />     return false;<br />     return obj.Amount == this.Amount &amp;&amp; obj.Unit == this.Unit;<br />   }<br />public override int GetHashCode()<br />   {<br />     int unitCode;<br />     if (Unit == &quot;RUR&quot;)<br />       unitCode = 1;<br />     else unitCode = 2;<br />     return (int) Amount + unitCode;<br />   }<br /><br />}<br />class Program<br />{<br />   static void Main(string[] args)<br />   {<br />     Money m1 = new Money(100, &quot;RUR&quot;);<br />     Money m2 = new Money(100, &quot;RUR&quot;);<br />     Money m3 = new Money(100, &quot;USD&quot;);<br />     Console.WriteLine(m1.GetHashCode()); // 101<br />     Console.WriteLine(m2.GetHashCode()); // 101<br />     Console.WriteLine(m3.GetHashCode()); // 102<br />     Console.ReadLine();<br /><br />   }<br />}</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">Здесь в качестве хеш-кода возвращается количество денег (целая часть) плюс код валюты. В результате теперь второе условие выполняется.</span></p></body></html>